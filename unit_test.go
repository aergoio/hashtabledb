package kv_log

import (
	"testing"
)

func TestShouldSkipSubtree(t *testing.T) {
	// Create a mock iterator with different range constraints

	// Test 1: No range constraints - should never skip
	it1 := &Iterator{
		start:     nil,
		end:       nil,
		keyPrefix: []byte("k"),
	}

	// Test various byte values - none should be skipped
	for i := 0; i < 256; i++ {
		if it1.shouldSkipSubtree(uint8(i)) {
			t.Errorf("shouldSkipSubtree with no range constraints should not skip byte %d", i)
		}
	}

	// Test 2: Range [key2, key5) - test specific cases
	it2 := &Iterator{
		start:     []byte("key2"),
		end:       []byte("key5"),
		keyPrefix: []byte{},
	}

	// Should not skip 'k' (first byte of "key2" and "key5")
	if it2.shouldSkipSubtree('k') {
		t.Error("shouldSkipSubtree should not skip 'k' for range [key2, key5)")
	}

	// Should skip 'a' (before "key2")
	if !it2.shouldSkipSubtree('a') {
		t.Error("shouldSkipSubtree should skip 'a' for range [key2, key5)")
	}

	// Should skip 'z' (after "key5")
	if !it2.shouldSkipSubtree('z') {
		t.Error("shouldSkipSubtree should skip 'z' for range [key2, key5)")
	}

	// Test 3: With prefix "ke" and range [key2, key5)
	it3 := &Iterator{
		start:     []byte("key2"),
		end:       []byte("key5"),
		keyPrefix: []byte("ke"),
	}

	// Should not skip 'y' (forms "key" which is valid prefix)
	if it3.shouldSkipSubtree('y') {
		t.Error("shouldSkipSubtree should not skip 'y' with prefix 'ke' for range [key2, key5)")
	}

	// Should skip 'a' (forms "kea" which is before "key2")
	if !it3.shouldSkipSubtree('a') {
		t.Error("shouldSkipSubtree should skip 'a' with prefix 'ke' for range [key2, key5)")
	}

	// Test 4: With prefix "key" and range [key2, key5)
	it4 := &Iterator{
		start:     []byte("key2"),
		end:       []byte("key5"),
		keyPrefix: []byte("key"),
	}

	// Should skip '1' (forms "key1" which is before "key2")
	if !it4.shouldSkipSubtree('1') {
		t.Error("shouldSkipSubtree should skip '1' with prefix 'key' for range [key2, key5)")
	}

	// Should not skip '2', '3', '4' (forms "key2", "key3", "key4" which are in range)
	for _, b := range []byte{'2', '3', '4'} {
		if it4.shouldSkipSubtree(b) {
			t.Errorf("shouldSkipSubtree should not skip '%c' with prefix 'key' for range [key2, key5)", b)
		}
	}

	// Should skip '5' and above (forms "key5" and higher which are >= end)
	for _, b := range []byte{'5', '6', '7', '8', '9'} {
		if !it4.shouldSkipSubtree(b) {
			t.Errorf("shouldSkipSubtree should skip '%c' with prefix 'key' for range [key2, key5)", b)
		}
	}

	// Test 5: Only start bound [key2, nil)
	it5 := &Iterator{
		start:     []byte("key2"),
		end:       nil,
		keyPrefix: []byte("key"),
	}

	// Should skip '1' (before start)
	if !it5.shouldSkipSubtree('1') {
		t.Error("shouldSkipSubtree should skip '1' with prefix 'key' for range [key2, nil)")
	}

	// Should not skip '2' and above
	for _, b := range []byte{'2', '3', '4', '5', '6', '7', '8', '9'} {
		if it5.shouldSkipSubtree(b) {
			t.Errorf("shouldSkipSubtree should not skip '%c' with prefix 'key' for range [key2, nil)", b)
		}
	}

	// Test 6: Only end bound [nil, key4)
	it6 := &Iterator{
		start:     nil,
		end:       []byte("key4"),
		keyPrefix: []byte("key"),
	}

	// Should not skip '1', '2', '3' (before end)
	for _, b := range []byte{'1', '2', '3'} {
		if it6.shouldSkipSubtree(b) {
			t.Errorf("shouldSkipSubtree should not skip '%c' with prefix 'key' for range [nil, key4)", b)
		}
	}

	// Should skip '4' and above (>= end)
	for _, b := range []byte{'4', '5', '6', '7', '8', '9'} {
		if !it6.shouldSkipSubtree(b) {
			t.Errorf("shouldSkipSubtree should skip '%c' with prefix 'key' for range [nil, key4)", b)
		}
	}
}
